/*
 * Vestra Compliance API
 *
 * Vestra Compliance Backend REST API for managing users, tasks, and compliance-related operations. This is version 1.0; future versions may introduce breaking changes. All endpoints require authentication unless explicitly stated otherwise.
 *
 * The version of the OpenAPI document: 1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`add_users_to_task`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddUsersToTaskError {
    Status401(models::GetUserList401Response),
    Status404(models::AddUsersToTask404Response),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_task`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTaskError {
    Status401(models::GetUserList401Response),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_task_result`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTaskResultError {
    Status401(models::GetUserList401Response),
    Status404(models::DeleteTask404Response),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_task`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTaskError {
    Status401(models::GetUserList401Response),
    Status404(models::DeleteTask404Response),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_users_from_task`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUsersFromTaskError {
    Status401(models::GetUserList401Response),
    Status404(models::AddUsersToTask404Response),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_task`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTaskError {
    Status401(models::GetUserList401Response),
    Status404(models::DeleteTask404Response),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_task_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTaskListError {
    Status401(models::GetUserList401Response),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_tasks_by_incident_result`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTasksByIncidentResultError {
    Status401(models::GetUserList401Response),
    Status404(models::GetTasksByIncidentResult404Response),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_upcoming_tasks_chart`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUpcomingTasksChartError {
    Status401(models::GetUserList401Response),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_task`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTaskError {
    Status401(models::GetUserList401Response),
    Status404(models::DeleteTask404Response),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}


/// Assigns one or more users to an existing task. Requires authentication with task update permissions.
pub async fn add_users_to_task(configuration: &configuration::Configuration, create_task_user_request: models::CreateTaskUserRequest) -> Result<models::CreateTaskUserResponse, Error<AddUsersToTaskError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_create_task_user_request = create_task_user_request;

    let uri_str = format!("{}/v1/tasks/users", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_create_task_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateTaskUserResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateTaskUserResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddUsersToTaskError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a new task with specified details such as name, priority, due date, and assigned users. Supports recurring tasks and reminders. Requires authentication with task creation permissions.
pub async fn create_task(configuration: &configuration::Configuration, create_task_request: models::CreateTaskRequest) -> Result<models::CreateTaskResponse, Error<CreateTaskError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_create_task_request = create_task_request;

    let uri_str = format!("{}/v1/tasks", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_create_task_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateTaskResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateTaskResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateTaskError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Records the result of a task, such as completion status and form data. Requires authentication with task update permissions.
pub async fn create_task_result(configuration: &configuration::Configuration, create_task_result_request: models::CreateTaskResultRequest) -> Result<models::CreateTaskResultResponse, Error<CreateTaskResultError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_create_task_result_request = create_task_result_request;

    let uri_str = format!("{}/v1/tasks/result", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_create_task_result_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateTaskResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateTaskResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateTaskResultError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes a task from the system by its ID. Requires authentication with task deletion permissions.
pub async fn delete_task(configuration: &configuration::Configuration, delete_task_request: models::DeleteTaskRequest) -> Result<models::DeleteTaskResponse, Error<DeleteTaskError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_delete_task_request = delete_task_request;

    let uri_str = format!("{}/v1/tasks", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_delete_task_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteTaskResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteTaskResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteTaskError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Unassigns one or more users from an existing task. Requires authentication with task update permissions.
pub async fn delete_users_from_task(configuration: &configuration::Configuration, delete_task_user_request: models::DeleteTaskUserRequest) -> Result<models::DeleteTaskUserResponse, Error<DeleteUsersFromTaskError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_delete_task_user_request = delete_task_user_request;

    let uri_str = format!("{}/v1/tasks/users", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_delete_task_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteTaskUserResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteTaskUserResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteUsersFromTaskError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetches the details of a specific task by its ID, including associated users and results. Requires authentication with task read permissions.
pub async fn get_task(configuration: &configuration::Configuration, id: i32) -> Result<models::GetTaskResponse, Error<GetTaskError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!("{}/v1/tasks/{id}", configuration.base_path, id=p_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTaskResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTaskResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTaskError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetches a list of tasks with pagination and extensive filtering options, including by name, priority, assignee, and date range. Supports sorting by due date or priority. Requires authentication with task read permissions.
pub async fn get_task_list(configuration: &configuration::Configuration, page: i32, page_size: i32, filter_by_name: Option<&str>, filter_by_priority: Option<&str>, filter_by_result: Option<&str>, filter_by_assignee_users: Option<&str>, filter_by_registers: Option<&str>, history: Option<bool>, order_by_due_date: Option<bool>, order_by_priority: Option<bool>, from_date: Option<String>, to_date: Option<String>, all_tasks: Option<bool>) -> Result<models::GetTaskListResponse, Error<GetTaskListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page = page;
    let p_page_size = page_size;
    let p_filter_by_name = filter_by_name;
    let p_filter_by_priority = filter_by_priority;
    let p_filter_by_result = filter_by_result;
    let p_filter_by_assignee_users = filter_by_assignee_users;
    let p_filter_by_registers = filter_by_registers;
    let p_history = history;
    let p_order_by_due_date = order_by_due_date;
    let p_order_by_priority = order_by_priority;
    let p_from_date = from_date;
    let p_to_date = to_date;
    let p_all_tasks = all_tasks;

    let uri_str = format!("{}/v1/tasks", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("page", &p_page.to_string())]);
    req_builder = req_builder.query(&[("page_size", &p_page_size.to_string())]);
    if let Some(ref param_value) = p_filter_by_name {
        req_builder = req_builder.query(&[("filter_by_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_filter_by_priority {
        req_builder = req_builder.query(&[("filter_by_priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_filter_by_result {
        req_builder = req_builder.query(&[("filter_by_result", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_filter_by_assignee_users {
        req_builder = req_builder.query(&[("filter_by_assignee_users", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_filter_by_registers {
        req_builder = req_builder.query(&[("filter_by_registers", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_history {
        req_builder = req_builder.query(&[("history", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_by_due_date {
        req_builder = req_builder.query(&[("order_by_due_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_by_priority {
        req_builder = req_builder.query(&[("order_by_priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_from_date {
        req_builder = req_builder.query(&[("from_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_to_date {
        req_builder = req_builder.query(&[("to_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_all_tasks {
        req_builder = req_builder.query(&[("all_tasks", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTaskListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTaskListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTaskListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetches all tasks associated with a specific incident result ID. Requires authentication with task read permissions.
pub async fn get_tasks_by_incident_result(configuration: &configuration::Configuration, incident_result_id: i32) -> Result<models::GetTasksByIncidentResponse, Error<GetTasksByIncidentResultError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_incident_result_id = incident_result_id;

    let uri_str = format!("{}/v1/tasks/by-incident-result/{incident_result_id}", configuration.base_path, incident_result_id=p_incident_result_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTasksByIncidentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTasksByIncidentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTasksByIncidentResultError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetches data for visualizing upcoming tasks within a specified date range, grouped by due date. Requires authentication with task read permissions.
pub async fn get_upcoming_tasks_chart(configuration: &configuration::Configuration, from_date: String, to_date: String, timezone: Option<&str>) -> Result<models::GetUpcomingTaskChartResponse, Error<GetUpcomingTasksChartError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_from_date = from_date;
    let p_to_date = to_date;
    let p_timezone = timezone;

    let uri_str = format!("{}/v1/tasks/upcoming-tasks-chart", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("from_date", &p_from_date.to_string())]);
    req_builder = req_builder.query(&[("to_date", &p_to_date.to_string())]);
    if let Some(ref param_value) = p_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetUpcomingTaskChartResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetUpcomingTaskChartResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUpcomingTasksChartError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates an existing task's details, such as name, priority, or assignees. Requires authentication with task update permissions.
pub async fn update_task(configuration: &configuration::Configuration, update_task_request: models::UpdateTaskRequest) -> Result<models::UpdateTaskResponse, Error<UpdateTaskError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_task_request = update_task_request;

    let uri_str = format!("{}/v1/tasks", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_update_task_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdateTaskResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdateTaskResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateTaskError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

